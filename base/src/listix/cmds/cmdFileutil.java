/*
library listix (www.listix.org)
Copyright (C) 2015-2026 Alejandro Xalabarder Aulet

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place - Suite 330, Boston, MA 02111-1307, USA.
*/


/*
   //(o) WelcomeGastona_source_listix_command STRCONV

   ========================================================================================
   ================ documentation for WelcomeGastona.gast =================================
   ========================================================================================

#gastonaDoc#

   <docType>    listix_command
   <name>       FILEUTIL
   <groupInfo>  system_files
   <javaClass>  listix.cmds.cmdFileutil
   <importance> 3
   <desc>       //Utilities with files

   <help>
      //
      // Some utilities with files and directories
      //
      //    Example:
      //       storing a memory file into a physical file
      //
      //       FILEUTIL, COPY, :mem myfile, MyFile.txt
      //

   <aliases>
      alias
      FILE
      FILEUTIL


   <syntaxHeader>
      synIndx, importance, desc
         1   ,   3       , //Copies one file into another creating target directories as needed
         2   ,   3       , //Copies one file into another creating target directories as needed
         3   ,   3       , //Copy a binary file into Hex text file
         4   ,   3       , //Copy a Hex text file into a binary file. The HexText file has to have the same format as the one generated by BIN TO HEX syntax
         5   ,   3       , //Ensure directories are created for a given file path
         6   ,   3       , //Split (actually copy) one file in smaller junks
         7   ,   3       , //Join a file from numbered parts

   <syntaxParams>
      synIndx, name          , defVal, desc
      1      , COPY          ,       , //
      1      , sourceFileName,       , //Source file name
      1      , targetFileName,       , //Target file name
      1      , sourceZipFile ,       , //Zip file if the source has to be seek there
      1      , offsetByte    ,       , //Byte where to start with (default 1)
      1      , lengthBytes   ,       , //Bytes to process (default or -1 until end of file)

      2      , MOVE          ,       , //
      2      , sourceFileName,       , //Source file name
      2      , targetFileName,       , //Target file name

      3      , BIN TO HEX    ,       , //
      3      , sourceFileName,       , //Source file name
      3      , targetFileName,       , //Target file name
      3      , offsetByte    ,       , //Byte where to start with (default 1)
      3      , lengthBytes   ,       , //Bytes to process (default or -1 until end of file)

      4      , HEX TO BIN    ,       , //
      4      , sourceFileName,       , //Source file name
      4      , targetFileName,       , //Target file name

      5      , ENSURE DIR 4 FILE,   , //
      5      , filePath     ,       , //File path whose directory path has to be ensured. Note that the file name is not relevant since it will not be created or changed.

      6      , SPLIT         ,       , //
      6      , sourceFileName,       , //Source file name
      6      , targetFileBaseName,   , //Target file name base xxx from which parts xxx.001, xxx.002 etc will be created. By default will be the same as the sourceFile
      6      , numerOfParts,         , //Number of parts to split the file in.
      6      , partBytesLimit,       , //Optional limit for each part given in bytes being 1024 the minimum. If no numberOfParts or partBytesLimit can be determined a partLimit of 10 MB will be set.

      7      , JOIN          ,       , //
      7      , sourceFileBaseName,   , //Source file name base xxx from which parts xxx.001, xxx.002 etc will be read
      7      , targetFileName,       , //Target file name for the joining file

   <options>
      synIndx, optionName  , parameters, defVal, desc

      1      , FROM ZIP,  zipFile,, //The source will be extracted from a zip(or jar) file
      3      , FROM ZIP,  zipFile,, //The source will be extracted from a zip(or jar) file


   <examples>
      gastSample

#**FIN_EVA#
*/

package listix.cmds;

import java.io.File;
import listix.*;
import listix.table.*;
import de.elxala.Eva.*;

import de.elxala.langutil.*;
import de.elxala.langutil.filedir.*;
import de.elxala.langutil.DateFormat;
import de.elxala.db.*;
import de.elxala.zServices.*;

public class cmdFileutil implements commandable
{
   /**
      get all the different names that the command can have
   */
   public String [] getNames ()
   {
      return new String []
      {
          "FILE",
          "FILEUTIL",
       };
   }

   /**
      Execute the commnad and returns how many rows of commandEva
      the command had.

         that           : the environment where the command is called
         commandEva     : the whole command Eva
         indxCommandEva : index of commandEva where the commnad starts
   */
   public int execute (listix that, Eva commands, int indxComm)
   {
      listixCmdStruct cmd = new listixCmdStruct (that, commands, indxComm);

      String oper = cmd.getArg(0);

      boolean OptSolveVar = ("1".equals (cmd.takeOptionString(new String [] {"SOLVE", "SOLVEVAR", "SOLVELSX", "SOLVELISTIX" }, "1"))) &&
                            ("0".equals (cmd.takeOptionString(new String [] {"ASTEXT" }, "0")));

      if (cmd.meantConstantString (oper, new String [] { "COPY", "COPIA" } ))
      {
         String sourceFile = cmd.getArg(1);
         String targetFile = cmd.getArg(2);
         long startByte = stdlib.atol (cmd.getArg(3));
         long lengthBytes = stdlib.atol (cmd.getArg(4));

         String sourceZipFile = cmd.takeOptionString(new String [] {"FROM ZIP", "ZIPFILE" }, "");

         if (!fileUtil.copyFileGeneral (sourceZipFile, sourceFile, targetFile, startByte, lengthBytes > 0 ? lengthBytes: -1, false))
            that.log ().err ("FILEUTIL", "Copy from [" + sourceFile + "] to [" + targetFile + "] failed!");
      }
      else if (cmd.meantConstantString (oper, new String [] { "MOVE", "MUEVE", "MOU" } ))
      {
         String sourceFile = cmd.getArg(1);
         String targetFile = cmd.getArg(2);

         if (!fileUtil.moveFile (sourceFile, targetFile))
            that.log ().err ("FILEUTIL", "Move from [" + sourceFile + "] to [" + targetFile + "] failed!");
      }
      else if (cmd.meantConstantString (oper, new String [] { "BINTOHEX", "TOHEX" } ))
      {
         String sourceFile = cmd.getArg(1);
         String targetFile = cmd.getArg(2);
         long startByte = stdlib.atol (cmd.getArg(3));
         long lengthBytes = stdlib.atol (cmd.getArg(4));

         if (!fileUtil.binaryFileToHexText (sourceFile, targetFile, startByte, lengthBytes > 0 ? lengthBytes:-1, false))
            that.log ().err ("FILEUTIL", "BINTOHEX From [" + sourceFile + "] to [" + targetFile + "] failed!");
      }
      else if (cmd.meantConstantString (oper, new String [] { "HEXTOBIN", "TOBIN" } ))
      {
         String sourceFile = cmd.getArg(1);
         String targetFile = cmd.getArg(2);

         if (!fileUtil.hexTextToBinaryFile (sourceFile, targetFile, false))
            that.log ().err ("FILEUTIL", "BINTOHEX From [" + sourceFile + "] to [" + targetFile + "] failed!");
      }
      else if (cmd.meantConstantString (oper, new String [] {"ENSUREDIR4FILE", "ENSUREDIRFORFILE"}))
      {
         fileUtil.ensureDirsForFile (cmd.getArg(1));
      }
      else if (cmd.meantConstantString (oper, new String [] { "SPLIT", "PARTES", "PARTS", "PARTEIX", "SEPARATE" } ))
      {
         String sourceFile = cmd.getArg(1);
         String targetFileBase = cmd.getArg(2);
         int numerOfPart = stdlib.atoi (cmd.getArg(3));
         int limitPartBytes = stdlib.atoi (cmd.getArg(4));

         if (!fileUtil.splitFile (sourceFile, targetFileBase, numerOfPart, limitPartBytes))
            that.log ().err ("FILEUTIL", "SPLIT from [" + sourceFile + "] to [" + targetFileBase + "] failed!");
      }
      else if (cmd.meantConstantString (oper, new String [] { "JOIN", "UNE", "UNEIX" } ))
      {
         String sourceFileBase = cmd.getArg(1);
         String targetFile = cmd.getArg(2);

         if (!fileUtil.joinFiles (sourceFileBase, targetFile, false))
            that.log ().err ("FILEUTIL", "JOIN from [" + sourceFileBase + "] to [" + targetFile + "] failed!");
      }
      else
         cmd.getLog ().err ("FILEUTIL", "syntax [" + oper + "] not recognized!");

      cmd.checkRemainingOptions ();
      return 1;
   }
}

